<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Topology | Experimental Marketing Agency</title>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0/css/bootstrap.min.css">

  <style>
    html, body { height: 100%; margin: 0; background: #000; color: #fff; text-align: center; overflow-x: hidden; }
    a, a:hover, a:visited { color: #fff; text-decoration: none; }

    .header { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; pointer-events: none; text-align: center; }
    .header .col { pointer-events: auto; }

    h1 { font-size: 112px; position: relative; }
    h1::after { content: ' GE'; font-size: 14px; position: absolute; top: 3px; padding-left: 5px; font-weight: 400; }
    h2::after { content: '2'; font-size: 12px; position: absolute; top: 14px; padding-left: 5px; }
    p { font-size: 20px; }

    .disable-selection { -moz-user-select: none; -ms-user-select: none; -webkit-user-select: none; user-select: none; }

    .section-full { width: 100%; height: 100vh; position: relative; overflow: hidden; }

    #container { width: 100%; height: 100vh; }

    #video-scrub { background: #000; border-top: 1px solid rgba(255,255,255,0.06); }
    #scrubCanvas { display:block; width:100%; height:100%; }
    .hint { position: absolute; left: 50%; bottom: 24px; transform: translateX(-50%); font-size: 14px; color: rgba(255,255,255,0.7); pointer-events: none; }

    #empty-block { background:#000; }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/89/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.3/TweenMax.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
</head>

<body>
  <div class="container-fluid header disable-selection">
    <div class="row w-100">
      <div class="col">
        <h1><strong>Topology</strong></h1>
        <p>Immersive Content and Metaverse Development Agency focused in experimental marketing</p>
      </div>
    </div>
  </div>

  <div id="container" class="section-full"></div>

  <section id="video-scrub" class="section-full disable-selection">
    <canvas id="scrubCanvas"></canvas>
    <div class="hint">Колесо мыши — скраб · зажми колесо и тяни вниз/вверх</div>
  </section>

  <!-- BLOCK 3: пустой чёрный экран -->
  <section id="block-3" class="section-full" aria-label="Empty black section"></section>

  <section id="empty-block" class="section-full"></section>

  <script id="vertexShader" type="x-shader/x-vertex">/* твой код шейдера без изменений */</script>
  <script id="fragmentShader" type="x-shader/x-vertex">/* твой код шейдера без изменений */</script>

  <script src="script.js"></script>

  <script>
  (function(){
    const frameCount = 65;
    const frameW = 1920, frameH = 810;
    const framePath = i => `${window.location.origin}${window.location.pathname.replace(/\/[^/]*$/, '')}/frames/frame_${String(i).padStart(2,'0')}.jpg`;

    const section = document.getElementById('video-scrub');
    const canvas = document.getElementById('scrubCanvas');
    const ctx = canvas.getContext('2d');

    const images = new Array(frameCount);
    let currentIndex = 0;

    function fitCanvas(){
      const dpr = window.devicePixelRatio || 1;
      const w = section.clientWidth, h = section.clientHeight;
      canvas.width = Math.round(w*dpr);
      canvas.height = Math.round(h*dpr);
      canvas.style.width = w+'px'; canvas.style.height = h+'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
      drawCurrent();
    }

    function drawImageCover(img){
      const cw = canvas.clientWidth, ch = canvas.clientHeight;
      const scale = Math.max(cw/frameW, ch/frameH);
      const dw = frameW*scale, dh = frameH*scale;
      const dx = (cw - dw)/2, dy = (ch - dh)/2;
      ctx.clearRect(0,0,cw,ch);
      if(img && img.complete && img.naturalWidth>0) ctx.drawImage(img, dx, dy, dw, dh);
    }

    function drawCurrent(){
      const img = images[currentIndex];
      if(img && img.complete && img.naturalWidth>0) drawImageCover(img);
    }

    function loadFrame(i){
      if(images[i]) return;
      const img = new Image();
      img.src = framePath(i);
      images[i] = img;
      img.onload = () => { if(i===0) drawCurrent(); };
      img.onerror = () => { console.warn('Не удалось загрузить кадр', img.src); };
    }

    function setIndex(i){
      const clamped = Math.max(0, Math.min(frameCount-1, i|0));
      if(clamped===currentIndex) return;
      currentIndex = clamped;
      if(!images[currentIndex]) loadFrame(currentIndex);
      requestAnimationFrame(drawCurrent);
    }

    // Скролл колесиком
    section.addEventListener('wheel', e=>{e.preventDefault(); setIndex(currentIndex + Math.sign(e.deltaY));},{passive:false});

    // Зажатое колесо мышки (middle button drag) вниз/вверх
    let middleDown = false, lastY = 0;
    window.addEventListener('mousedown', e=>{ if(e.button===1){ middleDown=true; lastY=e.clientY; e.preventDefault(); } });
    window.addEventListener('mouseup', e=>{ if(e.button===1) middleDown=false; });
    window.addEventListener('mousemove', e=>{
      if(middleDown){
        const dy = e.clientY - lastY;
        lastY = e.clientY;
        setIndex(currentIndex + Math.sign(dy));
      }
    });

    const ro = new ResizeObserver(fitCanvas); ro.observe(section);

    fitCanvas();
    loadFrame(0);
    setIndex(0);

    // ===== Middle mouse drag (global) to scrub by vertical movement =====
    let mmbDown = false;
    window.addEventListener('auxclick', (e)=>{ if(e.button===1) e.preventDefault(); });
    window.addEventListener('pointerdown', (e)=>{ if(e.button===1){ mmbDown = true; e.preventDefault(); }}, {passive:false});
    window.addEventListener('pointerup', (e)=>{ if(e.button===1){ mmbDown = false; }});
    window.addEventListener('pointermove', (e)=>{
      if(!mmbDown) return;
      // movementY > 0 (вниз) — следующий кадр
      setIndex(currentIndex + e.movementY * 0.2); // чувствительность можно поменять
    });

    // ===== Show header only while Block 1 (#container) is in view =====
    const headerEl = document.querySelector('.header');
    const firstBlock = document.getElementById('container');
    const io = new IntersectionObserver(([entry])=>{
      headerEl.style.display = entry.isIntersecting ? 'block' : 'none';
    }, { threshold: 0.05 });
    io.observe(firstBlock);
  })();
  </script>
</body>
</html>
